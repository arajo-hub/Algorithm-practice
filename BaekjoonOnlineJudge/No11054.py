import sys

n=int(sys.stdin.readline())
a=list(map(int, sys.stdin.readline().split()))

dpp = [0 for i in range(n)] # 가능한 왼쪽 오름차순 부분의 길이(인덱스는 그 지점까지의 수열이라는 의미)
dpm = [0 for i in range(n)] # 가능한 오른쪽 내림차순 부분의 길이(인덱스는 그 지점까지의 수열이라는 의미)
dpb = [0 for i in range(n)] # 왼쪽과 오른쪽 부분 길이의 합을 저장할 배열

# 바이토닉 수열은 두 부분으로 나눌 수 있다.
# 왼쪽의 오름차순 부분과 오른쪽의 내림차순 부분.
# 각 부분을 각각 구하고 후에 더하여 최대 길이를 구한다.

# 1. 왼쪽 오름차순 부분
# 기준점을 하나 잡고 그 기준점 이전까지의 가능한 수열의 길이를 배열에 넣고,
# 기준점을 하나 하나 늘려가면서 그 기준점 이전의 가능한 수열의 길이 중 제일 긴 길이를 dpp에 넣는 방식.
# 이 때 수열은 오름차순만!
for i in range(n): # 기준점을 하나 잡고
    for j in range(i): # 그 안의 숫자들을 기준점과 비교
        if a[i] > a[j] and dpp[i] < dpp[j]: # 기준점보다 작고, 그 숫자까지의 가능한 수열의 길이가 기준점의 가능한 수열의 길이보다 길다면
            dpp[i] = dpp[j] # 가능한 수열의 길이를 바꿔준다.
    dpp[i] += 1

# 오른쪽의 내림차순 부분.
for i in range(n-1, -1, -1): # 위와 다르게
    for j in range(n-1, i, -1): # 거꾸로 진행
        if a[i] > a[j] and dpm[i] < dpm[j]: # 기준점보다 작고, 그 숫자까지의 가능한 수열의 길이가 기준점의 가능한 수열의 길이보다 작다면
            dpm[i] = dpm[j] # 가능한 수열의 길이를 바꿔준다.
    dpm[i] += 1

for i in range(n):
    dpb[i] = dpp[i] + dpm[i]-1 # 왼쪽 오름차순 부분의 길이와 오른쪽 내림차순 부분의 길이를 더하고, 중복되는 기준점을 1개 빼준다.

print(max(dpb)) # 제일 긴 수열의 길이를 꺼낸다.