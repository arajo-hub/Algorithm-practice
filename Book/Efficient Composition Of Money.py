import sys

N, M=map(int, sys.stdin.readline().split())

moneyValue=[]
for i in range(N):
    moneyValue.append(int(sys.stdin.readline()))

dp=[10001]*(M+1)

dp[0]=0

for j in range(N): # j는 0, 1, 2, ..., N-1까지이다.
    for k in range(moneyValue[j], M+1): # k는 moneyValue[0]~M, moneyValue[1]~M, moneyvalue[2]~M, ..., moneyValue[N-1]~M까지의 값을 갖는다.
        if dp[k-moneyValue[j]]!=10001: # k는 1씩 늘어나고, moneyValue[j]는 고정. 제일 처음 k와 moneyValue[j]가 같을 경우, dp[0]이 되고, 0의 값을 가지므로
            dp[k]=min(dp[k], dp[k-moneyValue[j]]+1) # dp[moneyValue[j]]는 1이 된다. (dp[k]는 10001인 상태)
        # dp[moneyValue[j]]가 1이 되고, k는 1씩 늘어나는데,
        # dp[k-moneyValue[j]]가 지난번에 최소값을 찾아서 저장했던 곳이라면 dp[k-moneyValue[j]]는 10001과 같지 않아서 또 다시 최소값을 찾아서 저장하게 된다.
        # 결국 k가 movenyValue[j]의 배수가 될 때마다 새롭게 값을 저장하게 된다.

if dp[M]==10001:
    print(-1)
else:
    print(dp[M])

# 3, 5, 7의 가치를 가진 화폐가 있다고 해보자.
# 3원으로 만들 수 있는 금액은 3, 6, 9, ... 이 순서이다.
# 즉, 9원을 만드려면 6원을 만들어서 그냥 3을 더해주면 된다. 즉, 3원으로 9원을 만들 수 있는 화폐갯수=3원으로 6원을 만들 수 있는 화폐갯수+1
# 또, 6원을 만드려면 3원을 만들어서 그냥 3을 더해주면 된다. 즉, 3원으로 6원을 만들 수 있는 화폐갯수=3원으로 3원을 만들 수 있는 화폐갯수+1
# 5원으로 만들 수 있는 금액은 5, 10, 15, ... 이 순서이다.
# 즉, 15원을 만드려면 10원을 만들어서 그냥 5를 더해주면 된다. 즉, 5원으로 15원을 만들 수 있는 화폐갯수=5원으로 10원을 만들 수 있는 화폐갯수+1
# 또, 10원을 만드려면 5원을 만들어서 그냥 5를 더해주면 된다. 즉, 5원으로 10원을 만들 수 있는 화폐갯수=5원으로 5원을 만들 수 있는 화폐갯수+1
# 7원을 만드는 경우도 위와 같다.

# 예를 들어, 가치가 6원인 화폐도 있다고 해보자.
# 6원으로 6원을 만드려면 위에서 구한 3원으로 6원을 만드는 갯수 2개와 6원으로 6원을 만드는 갯수 1개 중 최소값을 고르면 된다. 즉, 1개가 된다.
# 6원으로 12원을 만드려면 6원을 만드는 갯수에 6원을 더하면 되므로 1+1해서 2가 된다.
# 6원으로 18원을 만드려면 위에서 구한 3원으로 18원을 만드는 갯수 6개와 6원으로 18원을 만드는 갯수 3개 중 최소값을 고르면 된다. 즉, 3개가 된다.

# 그러므로 어떤 금액 M을 만들고자 할 때, 그 금액 M을 만드는 갯수와 새로운 가치의 화폐로 M을 만드는 갯수 중 최소값을 고르면 된다.
# 6원을 만들고자 했을 때, 이미 3원으로 6원을 만들었던 최소갯수 2개와 6원으로 6원을 만드는 갯수 1개 중 최소값을 찾았던 것처럼.
# 6원으로 1개면 되는데 굳이 3원 2개짜리가 필요하지 않은 것처럼.